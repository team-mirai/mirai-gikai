# 議案詳細セクション内React Element挿入機能

## 概要

議案詳細ページ (`bill-detail`) の本文Markdown内の特定セクション（例: 3番目のH2見出しの直後）に、インタラクティブなReact Elementを動的に挿入する機能を実装する。

Server Componentsによる静的レンダリングを維持しつつ、挿入部分のみをClient Componentとして部分水和（Partial Hydration）することで、パフォーマンスとSEOを両立する。

## 背景・目的

### 現状の課題
- 議案詳細の本文コンテンツは完全に静的なHTML
- 特定の位置にインタラクティブなUI（例: 長押しセクション、CTA、広告枠など）を挿入したい
- 全体をClient Componentにすると不要な水和コストがかかる

### 目的
- **パフォーマンス最適化**: 本文の大部分は静的レンダリング、必要な部分のみ水和
- **柔軟性**: セクション番号や挿入コンポーネントを簡単に変更可能
- **SEO維持**: 挿入部もSSRされ、初期HTMLに含まれる

## 技術アプローチ

### アーキテクチャ

```
Markdown文字列
  ↓
remark-parse (Markdown → mdast)
  ↓
remark-rehype (mdast → hast)
  ↓
rehype-wrap-sections (セクションを<section>でラップ)
  ↓
【NEW】rehype-inject-element (指定H2の直後にReact Elementを挿入)
  ↓
rehype-sanitize
  ↓
hast-util-to-jsx-runtime (hast → React Element)
  ↓
React Server Component (静的部分) + Client Component (挿入部のみ水和)
```

### 主要技術スタック

- **unified**: テキスト処理パイプライン
- **rehype**: HTML AST (hast) 操作
- **hast-util-to-jsx-runtime**: HASTをReact Elementに変換
- **React Server Components**: 静的レンダリング
- **Client Components**: 部分水和

## 実装設計

### 1. rehype挿入プラグイン

**ファイル**: `web/src/lib/markdown/rehype-inject-element.ts`

**責務**:
- HASTツリーを走査し、指定されたn番目のH2要素を検出
- 該当H2の直後に、カスタムタグ（例: `<LongPressSection>`）を挿入
- プロパティをタグに渡す

**インターフェース**:
```typescript
interface RehypeInjectElementOptions {
  /** 挿入対象となるH2のインデックス（1-indexed） */
  targetH2Index: number;
  /** 挿入するカスタムタグ名 */
  tagName: string;
  /** タグに渡すprops */
  props?: Record<string, unknown>;
}
```

**挿入ロジック**:
- `unist-util-visit` でHASTツリーを走査
- `h2`要素をカウント
- `targetH2Index`に到達したら、その次のインデックスに新規Element nodeを挿入

### 2. 挿入用Client Component

**ファイル**: `web/src/features/bills/components/bill-detail/long-press-section.tsx`

**特性**:
- `'use client'` ディレクティブを持つ
- インタラクティブな機能（状態管理、イベントハンドリング）を提供
- 挿入時に渡されたpropsを受け取る

**例**:
```tsx
'use client'

interface LongPressSectionProps {
  billId?: string;
  position?: number;
}

export function LongPressSection({ billId, position }: LongPressSectionProps) {
  // インタラクティブなロジック
  return (
    <div className="my-8 p-6 bg-blue-50 rounded-lg">
      {/* ウィジェットUI */}
    </div>
  );
}
```

### 3. Markdownパーサー統合

**ファイル**: `web/src/lib/markdown/index.ts`

**変更点**:
- `dangerouslySetInnerHTML` から `hast-util-to-jsx-runtime` による動的レンダリングへ移行
- rehypeプラグインチェーンに `rehypeInjectElement` を追加
- `components` マッピングで `LongPressSection` を登録

**修正後の処理フロー**:
```typescript
import { toJsxRuntime } from 'hast-util-to-jsx-runtime';
import type {ReactElement} from "react";
import { Fragment } from 'react';
import { jsx, jsxs } from 'react/jsx-runtime';
import { rehypeInjectElement } from './rehype-inject-element';

// mdast作成
const mdast = unified()
  .use(remarkParse)
  .use(remarkBreaks)
  .parse(markdown);

// hast作成（rehypeプラグイン適用）
const hast = await unified()
  .use(remarkRehype)
  .use(rehypeWrapSections)
  .use(rehypeInjectElement, {
    targetH2Index: 3,
    tagName: 'LongPressSection',
    props: { billId: '123' }
  })
  .use(rehypeSanitize, customSchema)
  .use(rehypeExternalLinks)
  .use(rehypeEmbedYouTube)
  .run(mdast);

// JSXに変換
return toJsxRuntime(hast, {
  Fragment,
  jsx,
  jsxs,
  components: {
    LongPressSection // ← Client Componentとして水和
  }
});
```

### 4. BillContent コンポーネント修正

**ファイル**: `web/src/features/bills/components/bill-detail/bill-content.tsx`

**変更点**:
- `parseMarkdown()` の戻り値が `string` (HTML) から `ReactElement` に変更
- `dangerouslySetInnerHTML` を削除し、直接JSXとしてレンダリング

**修正後**:
```tsx
export async function BillContent({ bill }: BillContentProps) {
  const markdownContent = bill.bill_content?.content;
  if (!markdownContent) return null;

  const content = await parseMarkdown(markdownContent, {
    billId: bill.id
  });

  return (
    <div className="markdown-content ...">
      {content}
    </div>
  );
}
```

## データフロー

```
1. DBから取得したMarkdown文字列
   ↓
2. parseMarkdown(markdown, { billId })
   ↓
3. unified pipeline
   - Markdown → mdast
   - mdast → hast
   - hast内のH2を検出、3番目の直後に<LongPressSection billId={billId} />を挿入
   - sanitize/外部リンク/YouTube埋め込み処理
   ↓
4. hast → React Element (toJsxRuntime)
   ↓
5. Server Component (BillContent) がReact Elementを返す
   ↓
6. クライアント側でLongPressSectionのみ水和
```

## 設定可能な項目

| 項目 | デフォルト値 | 説明 |
|------|------------|------|
| `targetH2Index` | `3` | 挿入対象のH2見出し番号（1-indexed） |
| `tagName` | `'LongPressSection'` | 挿入するカスタムタグ名 |
| `props` | `{ billId }` | 挿入コンポーネントに渡すプロパティ |

将来的に複数箇所への挿入や、挿入条件の動的制御も可能。

## パフォーマンス最適化

### SSR vs CSR
- **SSR有効（デフォルト推奨）**: 初期HTMLに挿入部も含まれ、SEO対策になる。その後水和される。
- **CSR（遅延ローディング）**: `next/dynamic` で `ssr: false` にすると、クライアントで後挿入され、初期HTML軽量化。SEO不要な場合に有効。

### バンドルサイズ
- 挿入コンポーネントのみクライアントバンドルに含まれる
- 本文の静的部分はバンドルサイズに影響しない

## セキュリティ考慮事項

- `rehype-sanitize` は挿入プラグインの**前**に配置し、Markdown由来のHTMLを無害化
- 挿入するカスタムタグ（`LongPressSection`）は信頼できる自前コンポーネントなので、sanitize対象外
- sanitizeスキーマに `LongPressSection` を明示的に許可リストに追加

## テスト戦略

### 1. ユニットテスト
- **rehype-inject-element.test.ts**:
  - H2カウントが正しいか
  - 指定位置に要素が挿入されるか
  - propsが正しく渡されるか

### 2. 統合テスト
- **parseMarkdown統合**:
  - Markdown → React Element変換の全パイプラインが動作するか
  - 挿入コンポーネントが含まれているか

### 3. E2Eテスト
- 議案詳細ページで3番目のH2の後にLongPressSectionが表示されるか
- インタラクティブな動作（クリック、状態変化など）が正常か
- 水和エラーがないか

## ロールアウト計画

### フェーズ1: 基盤実装
- [ ] `rehype-inject-element.ts` 実装
- [ ] `long-press-section.tsx` 実装（基本UI）
- [ ] `parseMarkdown` を `toJsxRuntime` に移行
- [ ] `bill-content.tsx` 修正

### フェーズ2: 動作検証
- [ ] ユニットテスト作成
- [ ] ローカル環境で動作確認
- [ ] 水和エラーチェック

### フェーズ3: 本番投入
- [ ] ステージング環境デプロイ
- [ ] パフォーマンス計測（Lighthouse, Core Web Vitals）
- [ ] 本番デプロイ

## 今後の拡張性

- **複数箇所への挿入**: 配列で複数の挿入ポイントを指定
- **条件付き挿入**: 議案カテゴリや文字数で挿入を制御
- **A/Bテスト**: 挿入位置や内容を動的に切り替え
- **別のウィジェット**: 広告、関連記事、投票UIなど

## 参考資料

- [unified公式ドキュメント](https://unifiedjs.com/)
- [rehypeプラグイン開発ガイド](https://unifiedjs.com/learn/guide/create-a-rehype-plugin/)
- [hast-util-to-jsx-runtime](https://github.com/syntax-tree/hast-util-to-jsx-runtime)
- [React Server Components解説](https://react.dev/reference/rsc/server-components)
- [Next.js部分水和パターン](https://nextjs.org/docs/app/building-your-application/rendering/composition-patterns)
