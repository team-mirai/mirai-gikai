# テストガイドライン

このドキュメントは、mirai-gikai プロジェクトにおけるテストの書き方・運用方法をまとめたガイドラインです。

## テストの種類と構成

プロジェクトでは以下の4種類のテストを運用します（段階的に導入）。

| 種類 | 配置場所 | 実行環境 | 実行コマンド | 用途 | 状態 |
|------|----------|----------|-------------|------|------|
| ユニットテスト | `web/src/**/*.test.ts` | Vitest | `pnpm --filter web test` | 純粋関数・ユーティリティのテスト | 導入済み |
| RLS/DBファンクションテスト | `tests/supabase/` | Vitest + Node.js | 未定 | RLSポリシー・SQL関数の検証 | 未導入 |
| 統合テスト | `tests/integration/` | Vitest + Node.js | 未定 | ユースケース層のシナリオテスト | 未導入 |
| E2Eテスト | `tests/e2e/` | Playwright | 未定 | ブラウザ上のユーザーフロー検証 | 未導入 |

## CI実行フロー

PR が作成されると、`code_check.yml` で以下が順次実行されます。

```
PR Created / Push to main
  └── lint-and-typecheck
      ├── pnpm run lint（Biome format + lint）
      ├── pnpm run typecheck（TypeScript 型チェック）
      └── pnpm run test（全ワークスペースの Vitest 実行）
```

全ステップがパスするとマージ可能になります。

---

## ユニットテスト

### 対象

- 外部依存のない純粋関数（`lib/`、`features/**/utils/` など）
- 計算ロジック、文字列処理、データ変換、Markdown 処理

### 配置ルール

実装ファイルと同じディレクトリに `*.test.ts` として配置します。

```
web/src/
├── lib/
│   ├── ai/
│   │   ├── calculate-ai-cost.ts
│   │   └── calculate-ai-cost.test.ts    ← 同階層に配置
│   ├── markdown/
│   │   ├── index.ts
│   │   ├── index.test.ts
│   │   ├── rehype-embed-youtube.ts
│   │   └── rehype-embed-youtube.test.ts
│   └── stream/
│       ├── inject-json-fields.ts
│       └── inject-json-fields.test.ts
└── features/
    └── interview-session/client/utils/
        ├── calc-interview-progress.ts
        └── calc-interview-progress.test.ts
```

### 書き方

```typescript
// web/src/lib/ai/calculate-ai-cost.test.ts
import { describe, expect, it } from "vitest";
import { calculateUsageCostUsd, type SanitizedUsage } from "./calculate-ai-cost";
import { AI_MODELS } from "./models";

describe("calculateUsageCostUsd", () => {
  it("トークンが0の場合は0を返す", () => {
    const usage: SanitizedUsage = {
      inputTokens: 0,
      outputTokens: 0,
      totalTokens: 0,
    };
    expect(calculateUsageCostUsd(AI_MODELS.gpt4o, usage)).toBe(0);
  });

  it("既知モデルのコストを正しく計算する", () => {
    const usage: SanitizedUsage = {
      inputTokens: 500,
      outputTokens: 1000,
      totalTokens: 1500,
    };
    // 500 * $2.50/M + 1000 * $10.00/M = 0.00125 + 0.01 = 0.01125
    expect(calculateUsageCostUsd(AI_MODELS.gpt4o, usage)).toBeCloseTo(0.01125);
  });

  it("未知のモデルでは例外をスローする", () => {
    const usage: SanitizedUsage = {
      inputTokens: 1000,
      outputTokens: 1000,
      totalTokens: 2000,
    };
    expect(() => calculateUsageCostUsd("unknown-model", usage)).toThrow(
      'Unknown pricing for model "unknown-model"'
    );
  });
});
```

### テスト実行コマンド

```bash
# 全テスト実行
pnpm --filter web test

# ウォッチモード（開発中の利用推奨）
pnpm --filter web test:watch

# UIモード（ブラウザでテスト結果を確認）
pnpm --filter web test:ui
```

### ポイント

- **mock は極力使わない**: `vi.mock("server-only")` 等のモックに頼らず、テスト対象のロジックを純粋関数として `shared/` に切り出してからテストする。`server-only` や外部依存を含むファイルからは re-export で参照を維持する
- **ローカルサービスは real で動かす**: Supabase などローカルで起動できるサービスはモックせず、実際のローカルインスタンスに接続してテストする
- **外部 API は DI でモックする**: OpenAI などの外部 API クライアントはインターフェースを定義し、テストでは Fake/Mock 実装に差し替える
- `vitest.config.mts` で `globals: true` が有効なため `describe`/`it`/`expect` はグローバルで使えるが、明示的に `import { describe, expect, it } from "vitest"` する
- テスト内で意図的に型を崩す場合は `as any` を使用してよい（`biome-ignore` コメント付き）
- 浮動小数点の比較には `toBeCloseTo()` を使う
- AI コスト計算や Markdown 処理などデータ変換の変更時は必ず回帰テストを追加する

---

## RLS/DBファンクションテスト（未導入）

### 対象

- Supabase RLS ポリシー（テーブルごとのアクセス制御）
- Supabase SQL 関数（`get_admin_users` など）

### 前提

- ローカル Supabase が起動していること（`npx supabase start`）
- シードデータが投入済みであること（`pnpm seed`）

### 設計方針

```
tests/
└── supabase/
    ├── rls/              # RLSポリシーテスト
    ├── db-function/      # DBファンクションテスト
    └── utils.ts          # Supabaseテスト共通ユーティリティ
```

- `service_role` キーを使った管理者クライアントと、`anon` キーや認証済みユーザークライアントを使い分けてテスト
- RLS ポリシーのテストでは「見えるべきデータが見える」「見えてはいけないデータが見えない」の両方を検証

---

## 統合テスト（未導入）

### 対象

- Server Actions（`features/**/server/actions/`）
- ビジネスロジック層（`features/**/server/services/`）
- 実際のローカル Supabase に対して DB 操作を行うシナリオテスト

### 設計原則

#### 1. SupabaseClient を DI する

ユースケース関数やサービスは `SupabaseClient` をパラメータとして受け取る設計にする。テストでは管理者権限クライアントや認証済みクライアントを渡す。

```typescript
// サービス関数の定義
export async function updateBillStatus(
  supabase: SupabaseClient,
  input: { billId: string; status: string },
): Promise<UpdateBillResult> { ... }

// テストでの呼び出し
const result = await updateBillStatus(testUser.client, {
  billId: "test-bill-id",
  status: "approved",
});
```

#### 2. 外部 API は Fake で差し替える

外部 API クライアントはインターフェースを定義し、テストでは Fake 実装を使う。

#### 3. DB 状態を必ず検証する（最重要）

**ユースケース関数の戻り値だけでなく、DB の状態を必ず検証する。** これにより、実際にデータが永続化されたことを保証する。

```typescript
// 悪い例: 戻り値だけの検証
const result = await updateBillStatus(testUser.client, { ... });
expect(result).toEqual({ success: true });  // これだけでは不十分

// 良い例: DB状態も検証
const result = await updateBillStatus(testUser.client, { ... });
expect(result).toEqual({ success: true });

const { data: bill } = await adminClient
  .from("bills")
  .select("status")
  .eq("id", billId)
  .single();
expect(bill?.status).toBe("approved");  // DBに反映されたことを確認
```

#### 4. エラーケースでも DB 状態を検証する

エラーが返された場合に、**意図しないデータが作成・変更されていないこと**を DB レベルで確認する。

#### 5. クリーンアップを徹底する

テストで作成したデータは `afterEach` で必ず削除する。

---

## E2Eテスト（未導入）

### 対象

- ブラウザ上のユーザーフロー（議案閲覧、インタビュー操作、管理画面操作等）

### 設計方針

- Playwright を使用
- テストユーザーの自動作成・削除をフィクスチャで管理
- CI では Supabase + Next.js ビルド後に実行

---

## テスト作成時の注意事項

### テスト追加が必要なケース

CLAUDE.md に記載の通り、以下のケースではテスト追加が必須です：

- AI コスト計算ロジックの変更
- Markdown 処理ロジックの変更
- データ変換ロジックの変更

加えて、以下のケースでもテスト追加を推奨します：

- 新しいユーティリティ関数の追加
- 既存ロジックのリファクタリング（回帰テストとして）
- バグ修正（再発防止テストとして）

### describe/it の構造化

関連するケースは `describe` でグループ化し、日本語で意図を明確にします。

```typescript
describe("calcInterviewProgress", () => {
  describe("totalQuestionsが未定義または0の場合", () => {
    it("undefinedならnullを返す", () => { ... });
    it("0ならnullを返す", () => { ... });
  });

  describe("chatステージ", () => {
    it("質問が未開始なら0%", () => { ... });
    it("2問目に進んだら1問完了で16%（1/5 × 80）", () => { ... });
  });
});
```

### 一意性の確保

テストデータの ID やメールアドレスには `Date.now()` や `crypto.randomUUID()` を含めて一意にします。

```typescript
const email = `test-${Date.now()}@example.com`;
```

### テストヘルパーの活用

共通的な変換処理（HTML 正規化など）はヘルパー関数に切り出します。

```typescript
function normalizeHTML(html: string): string {
  return html.replace(/>\s+</g, "><").replace(/\s+/g, " ").trim();
}
```

### PR 前の確認

```bash
# ウォッチモードで開発中に確認
pnpm --filter web test:watch

# PR 前に全テスト実行
pnpm test
```
